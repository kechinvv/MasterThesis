= Тестирование

Для тестирования предложенного подхода и его реализации были получены поведенческие модели для классов нескольких библиотек:

- java.util.zip.ZipOutputStream
- java.lang.StringBuilder
- java.security.Signature
- java.net.Socket
- org.columba.ristretto.smtp.SMTPProtocol

Все из этих классов, имеют модели разной сложности и, за исключением  StringBuilder, рассматривались в упомянутых исследованиях@specforge@medv@tautoko, авторы которых сравнивали полученные КА с эталонными моделями. Эти модели расположены в репозитории GitHub#footnote("https://github.com/ModelInference/SpecForge"). Не смотря на то, что авторы использовали их как эталон, некоторые из представленных КА явно неполны и ограничены определенным набором вызовов (Signature и SMTPProtocol), а модель класса Socket похожа на полученную автоматически и отредактированную человеком. По этой причине сравнение и оценка полученных автоматов будет приблизительна и субъективна. 

Стоит сказать, что это можно решить созданием своих эталонов, однако это трудоемкая задача, о чем сообщалось в каждом исследовании с проведенным тестированием. Решалась она работой нескольких человек, а все модели, которые можно было переиспользовать из других исследований -- переиспользовались. Поэтому в рамках выполняемой работы задача составления эталонов не выполнялась.

Оценка точности и полноты получаемых поведенческих моделей не проводилась, так как работа не предлагает собственные алгоритмы восстановления. Подробное сравнение алгоритмов проведено в исследовании "Automatic mining of specifications from invocation traces and method invariants"@medv. На трассы также влияет корректность получаемых трасс:
- Обход ICFG может получать все возможные пути исполнения, однако часто программы пишутся так, что не все состояния достижимы при реальном исполнении
- Фаззинг способен создавать некорректные входные объекты, что в теории может привести к появлению трасс, невозможных при реальном использовании (проблема, аналогичная предыдущему пункту)
- Анализ указателей имеет определенную погрешность

Влияние первых двух факторов сложно оценить и учесть. Что касается анализа указателей, то определением точности алгоритма Андерсена на практике занимались авторы работы "The Flow-Insensitive Precision of Andersen's Analysis in Practice"@andersen_prec. Результат показал, что точность очень сильно варьируется от проекта к проекту. Для полноты проведенного тестирования, следует оценивать влияние качества трасс на получаемые КА, но ввиду отсутствия качественных эталонов и сложности их составления, эта часть не будет выполнена в рамках данной работы.

== Полученные модели

Все модели получены в результате объединения трасс, полученных статическим и динамическим путем. Сделано это по той причине, что динамические трассы не содержат новых покрытий, но полученные таким образом последовательности вызовов имеют более высокий уровень доверия.

В качестве источника проектов использовался GitHub, так как наиболее демонстративными и понятными примерами являются классы стандартной библиотеки, не хранящиеся в Maven Central. При этом библиотеки с Maven Central в результате локальных экспериментов обладали наиболее высоким процентом успешного применения фаззинга, что повышает качество получаемых моделей.

Запуск инструмента для каждого целевого класса выполнялся в следующих условиях:
- Время работы 4 часа
- Системные характеристики: 20 гигабайт оперативной памяти, процессор Intel Core i5-8300H CPU  2.30GHz, 4 физических ядра

=== ZipOutputStream

#figure(
  image("../img/zipoutputstream.jpg"),
  caption: "Полученная модель ZipOutputStream"
) <own_zip>


#figure(
  image("../img/zip_ground.png"),
  caption: "Эталонная модель ZipOutputStream"
) <ground_zip>


=== StringBuilder

#figure(
  image("../img/stringbuilder.png"),
  caption: "Полученная модель StringBuilder"
) <own_strbuilder>

=== Signature

#figure(
  image("../img/signature.png"),
  caption: "Полученная модель Signature"
) <own_signature>

=== Socket

#figure(
  image("../img/socket.png"),
  caption: "Полученная модель Socket"
) <own_socket>

#figure(
  image("../img/socket_ground.png"),
  caption: "Эталонная модель Socket"
) <ground_socket>

=== SMTPProtocol

#figure(
  image("../img/smtp.png"),
  caption: "Полученная модель SMTP"
) <own_smtp>

== Выводы