= Тестирование

Для тестирования предложенного подхода и его реализации были получены поведенческие модели для классов нескольких библиотек:

- java.util.zip.ZipOutputStream
- java.lang.StringBuilder
- java.security.Signature
- java.net.Socket
- org.columba.ristretto.smtp.SMTPProtocol

Все из этих классов, имеют модели разной сложности и, за исключением  StringBuilder, рассматривались в упомянутых исследованиях@specforge@medv@tautoko, авторы которых сравнивали полученные КА с эталонными моделями. Эти модели расположены в репозитории GitHub#footnote("https://github.com/ModelInference/SpecForge"). Не смотря на то, что авторы использовали их как эталон, некоторые из представленных КА явно неполны и ограничены определенным набором вызовов (Signature и SMTPProtocol), а модель класса Socket похожа на полученную автоматически и отредактированную человеком. По этой причине сравнение и оценка полученных автоматов будет приблизительна и субъективна. 

Стоит сказать, что это можно решить созданием своих эталонов, однако это трудоемкая задача, о чем сообщалось в каждом исследовании с проведенным тестированием. Решалась она работой нескольких человек, а все модели, которые можно было переиспользовать из других исследований -- переиспользовались. Поэтому в рамках выполняемой работы задача составления эталонов не выполнялась.

Оценка точности и полноты получаемых поведенческих моделей не проводилась, так как работа не предлагает собственные алгоритмы восстановления. Подробное сравнение алгоритмов проведено в исследовании "Automatic mining of specifications from invocation traces and method invariants"@medv. На трассы также влияет корректность получаемых трасс:
- Обход ICFG может получать все возможные пути исполнения, однако часто программы пишутся так, что не все состояния достижимы при реальном исполнении
- Фаззинг способен создавать некорректные входные объекты, что в теории может привести к появлению трасс, невозможных при реальном использовании (проблема, аналогичная предыдущему пункту)
- Анализ указателей имеет определенную погрешность

Влияние первых двух факторов сложно оценить и учесть. Что касается анализа указателей, то определением точности алгоритма Андерсена на практике занимались авторы работы "The Flow-Insensitive Precision of Andersen's Analysis in Practice"@andersen_prec. Результат показал, что точность очень сильно варьируется от проекта к проекту. Для полноты проведенного тестирования, следует оценивать влияние качества трасс на получаемые КА, но ввиду отсутствия качественных эталонов и сложности их составления, эта часть не будет выполнена в рамках данной работы.

== Полученные модели

Все модели получены в результате объединения трасс, полученных статическим и динамическим путем. Сделано это по той причине, что динамические трассы не содержат новых покрытий, но полученные таким образом последовательности вызовов имеют более высокий уровень доверия.

В качестве источника проектов использовался GitHub, так как наиболее демонстративными и понятными примерами являются классы стандартной библиотеки, не хранящиеся в Maven Central. При этом библиотеки с Maven Central в результате локальных экспериментов обладали наиболее высоким процентом успешного применения фаззинга, что повышает качество получаемых моделей.

Запуск инструмента для каждого целевого класса выполнялся в следующих условиях:
- Время работы 1-2 часа
- Системные характеристики: 20 гигабайт оперативной памяти, процессор Intel Core i5-8300H CPU  2.30GHz, 4 физических ядра

=== ZipOutputStream

Полученная модель представлена на @own_zip, эталонная на @ground_zip. Важно отметить, что к данному эталону не возникает вопросов о его полноте и методу получения. Из рисунков видно, что обе модели покрывают все необходимые вызовы. Можно заметить, что получаемая модель не противоречит эталону, но не содержит всех переходов и является неполной. Более длительный поиск проектов и трасс может улучшить ситуацию, но вряд ли даст эталонный результат.

#figure(
  image("../img/zip2.png", height: 40%),
  caption: "Полученная модель ZipOutputStream"
) <own_zip>


#figure(
  image("../img/zip_ground.png", height: 40%),
  caption: "Эталонная модель ZipOutputStream"
) <ground_zip>


=== StringBuilder

Для данной модели на @own_strbuilder нет эталона, но легко заметить, что модель не противоречит реальному использованию StringBuilder. Тем не менее, получены не все возможные вызовы библиотеки и полученный КА очень простой. Более длительное применение инструмента точно обогатит данную модель переходами.

#figure(
  image("../img/stringbuilder.png"),
  caption: "Полученная модель StringBuilder"
) <own_strbuilder>

=== Signature

Для полученной модели, представленной на @own_signature, существует эталонная модель, но она содержит лишь небольшую часть действительно возможных вызовов и переходов. Тем не менее, из модели видно, что явно выделяются определенные повторяющиеся паттерны переходов между состояниями, а также есть дубликаты переходов. Это является следствием работы алгоритма и не может быть решено без потери подробностей или использования другого алгоритма.

#figure(
  image("../img/signature.png"),
  caption: "Полученная модель Signature"
) <own_signature>

=== Socket

При сравнении полученной модели с @own_socket и эталона @ground_socket видно, что полученный КА явно не содержит всех вызовов, а также имеет слабое обобщение. Также здесь видна погрешность статического подхода в том, что потеряно создание объекта и некоторые переходы происходят без вызова конструктора. Тем не менее, из полученного КА видны дальнейшие точки для ручного исправления. Например, объединение get методов в один переход.

Что касается эталонной модели, к ней есть вопросы, так как она явно может быть обобщена лучше, а состояние S9 играет роль начального, хотя вызова конструктора для нее нет. В целом это допустимо, если библиотека содержит фабрики объектов. Тем не менее, складывается впечатление, что это обработанный вручную и автоматически полученный КА. 

#figure(
  image("../img/socket.png"),
  caption: "Полученная модель Socket"
) <own_socket>

#figure(
  image("../img/socket_ground.png"),
  caption: "Эталонная модель Socket"
) <ground_socket>

=== SMTPProtocol

Для модели с @own_smtp также существует неполная эталонная модель, но она содержит очень малое количество доступных вызовов. Не смотря на это, из полученного КА также видно, что он имеет слабую обобщенность и визуально выделяющиеся повторяющиеся паттерны вызовов, которые скорее всего могут быть объединены вручную. Также следует отметить наличие большинства методов класса, что говорит об успехе сбора трасс.

#figure(
  image("../img/smtp.png"),
  caption: "Полученная модель SMTP"
) <own_smtp>

== Выводы

Получение поведенческих моделей с помощью предложенного подхода и его реализации показало свою работоспособность. Получаемые модели действительно являются аппроксимацией сверху, а представленный подход требует улучшений в области извлечения трасс и использованию алгоритмов восстановления. Тем не менее, в автоматическом режиме успешно выполняется получение проектов, использующих заданную библиотеку, происходит извлечение трасс как статически, так и динамически, а восстанавливаемые модели соответствуют полученным трассам и могут быть интерпретированы человеком для дальнейшей доработки. Более того, манипуляция параметрами поиска проектов, входных точек и параметров алгоритма восстановления может сильно улучшить результат.