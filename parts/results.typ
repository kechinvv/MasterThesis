= Тестирование

Для тестирования предложенного подхода и его реализации были получены поведенческие модели для классов нескольких библиотек:

- java.util.zip.ZipOutputStream
- java.lang.StringBuilder
- java.security.Signature
- java.net.Socket
- org.columba.ristretto.smtp.SMTPProtocol

Каждый из этих классов имеет модель разной сложности и, за исключением StringBuilder, рассматривался в упомянутых исследованиях@specforge@medv@tautoko, авторы которых сравнивали полученные КА с эталонными моделями. Эти модели расположены в репозитории GitHub#footnote("https://github.com/ModelInference/SpecForge"). Несмотря на то, что авторы использовали их как эталон, некоторые из представленных КА явно неполны и ограничены определенным набором вызовов (Signature и SMTPProtocol), а модель класса Socket, похоже, получена автоматически и вручную отредактирована. По этой причине сравнение и оценка полученных автоматов будут приблизительны и субъективны. 

Стоит сказать, что отсутствие эталонов можно решить созданием собственных, однако это трудоемкая задача, о чем сообщалось в исследованиях с проведенным тестированием. Задача решалась усилиями нескольких человек, а все модели, которые можно было переиспользовать из других исследований, использовались повторно@medv. Поэтому в рамках выполняемой работы задача составления эталонов не выполнялась.

Оценка точности и полноты получаемых поведенческих моделей не проводилась, так как в работе не разработаны собственные алгоритмы восстановления. Подробное сравнение алгоритмов проведено в исследовании "Automatic mining of specifications from invocation traces and method invariants"@medv. На качество моделей также влияет корректность получаемых трасс:
- Обход ICFG может получать все возможные пути исполнения, однако часто программы пишутся так, что не все состояния достижимы при реальном исполнении
- Фаззинг способен создавать некорректные входные объекты, что в теории может привести к появлению трасс, невозможных при реальном использовании (проблема, аналогичная предыдущему пункту)
- Анализ указателей имеет определенную погрешность

Влияние первых двух факторов сложно оценить и учесть. Что касается анализа указателей, то определением точности алгоритма Андерсена на практике занимались авторы работы "The Flow-Insensitive Precision of Andersen's Analysis in Practice"@andersen_prec. Результат показал, что точность очень сильно варьируется от проекта к проекту. Для полноты проведенного тестирования следует оценивать влияние качества трасс на получаемые КА, но ввиду отсутствия качественных эталонов и сложности их составления, эта часть не рассматривается в рамках данной работы.

== Полученные модели

Все модели восстановлены в результате объединения трасс, полученных статическим и динамическим путем. Сделано это по той причине, что динамические трассы в среднем не добавляют нового покрытия, но полученные таким образом последовательности вызовов более надежны.

В качестве источника проектов использовался GitHub, так как наиболее наглядными и понятными примерами являются классы стандартной библиотеки, отсутствующие в Maven Central. Однако библиотеки с Maven Central в результате экспериментов обладали наиболее высоким процентом успешного применения фаззинга, что повышало качество получаемых моделей.

Запуск инструмента для каждого целевого класса выполнялся в следующих условиях:
- Лимит получаемых проектов: 100
- Лимит получаемых трасс: 1000000
- Лимит длины трассы: 200 вызовов
- Ограничение глубины обхода: 10
- Параметр k для k-tail: 1 или 2
- Количество запусков фаззера: 10000
- Ограничение времени работы фаззера: 300 секунд
- Системные характеристики: 20 гигабайт оперативной памяти, процессор Intel Core i5-8300H CPU 2.30GHz, 4 физических ядра

=== ZipOutputStream

Полученная модель представлена на @own_zip, а эталонная -- на @ground_zip. Важно отметить, что к данному эталону не возникает вопросов о его полноте и методе получения. Из рисунков видно, что обе модели покрывают все необходимые вызовы. Можно заметить, что полученная модель не противоречит эталону, но не содержит всех переходов и является неполной. Более длительный поиск проектов и трасс может улучшить ситуацию, но вряд ли даст эталонный результат.

#figure(
  image("../img/zip2.png", height: 40%),
  caption: "Полученная модель ZipOutputStream"
) <own_zip>


#figure(
  image("../img/zip_ground.png", height: 40%),
  caption: "Эталонная модель ZipOutputStream"
) <ground_zip>


=== StringBuilder

Для данной модели на @own_strbuilder нет эталона, но легко заметить, что она не противоречит реальному использованию StringBuilder. Тем не менее, получены не все возможные вызовы библиотеки, а восстановленный КА тривиален. Более длительное применение инструмента обогатит данную модель новыми состояниями и переходами.

#figure(
  image("../img/stringbuilder.png"),
  caption: "Полученная модель StringBuilder"
) <own_strbuilder>

=== Signature

Для полученной модели, представленной на @own_signature, существует эталон, но он содержит лишь небольшую часть действительно возможных вызовов и переходов. Тем не менее, из модели видно, что явно выделяются определенные повторяющиеся паттерны переходов между состояниями, а также присутствуют их дубликаты. Это является следствием работы алгоритма восстановления и не может быть решено без потери подробностей КА или использования другого алгоритма.

#figure(
  image("../img/signature.png"),
  caption: "Полученная модель Signature"
) <own_signature>

=== Socket

При сравнении полученной модели с @own_socket и эталона с @ground_socket видно, что полученный КА явно не содержит всех вызовов, а также имеет недостаточное обобщение. Также здесь видна погрешность статического подхода в том, что потеряно создание объекта и некоторые переходы происходят без вызова конструктора. Тем не менее, из полученного КА видны дальнейшие точки для ручного исправления. Например, объединение методов доступа к данным (get) в один переход.

Что касается эталонной модели, она вызывает сомнения, так как похоже, что КА может быть обобщен лучше. Состояние S9 играет роль начального, хотя вызова конструктора для неё нет. Это поведение также наблюдается в полученном КА и допускается, если объект был создан методом другого класса библиотеки. Тем не менее, складывается впечатление, что это автоматически полученный и обработанный вручную КА. 

#figure(
  image("../img/socket.png"),
  caption: "Полученная модель Socket"
) <own_socket>

#figure(
  image("../img/socket_ground.png"),
  caption: "Эталонная модель Socket"
) <ground_socket>

=== SMTPProtocol

Для модели с @own_smtp также существует неполная эталонная модель, но она содержит очень малое количество доступных вызовов. Несмотря на это, из полученного КА также видно, что он имеет слабую обобщенность и визуально выделяющиеся повторяющиеся паттерны вызовов, которые, скорее всего, могут быть объединены вручную. Также следует отметить наличие большинства методов класса, что говорит об успехе сбора трасс.

#figure(
  image("../img/smtp.png"),
  caption: "Полученная модель SMTP"
) <own_smtp>

== Выводы

Получение поведенческих моделей с помощью предложенного подхода и его реализации показало свою работоспособность. Получаемые модели действительно являются аппроксимацией сверху, а представленный подход требует улучшений в области извлечения трасс и алгоритмов восстановления. Тем не менее, в автоматическом режиме успешно выполняется получение проектов, использующих заданную библиотеку, и происходит извлечение трасс как с применением статического, так и динамического подхода. Восстанавливаемые модели соответствуют полученным трассам и могут быть интерпретированы человеком для дальнейшей доработки. Более того, манипуляция параметрами поиска проектов, входных точек и параметров алгоритма восстановления может сильно улучшить результат.