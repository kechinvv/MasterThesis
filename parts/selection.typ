= Задача извлечения поведенческих моделей и анализ путей ее решения <selection_part>

Задача извлечения поведенческих моделей библиотек состоит из нескольких составляющих:
- Поиск проектов, использующих заданную библиотеку
- Подготовка проектов к анализу
- Извлечение трасс и состояний
- Восстановление автоматов из трасс

Каждая из этих задач требует отдельного внимания, а также определенного уровня согласованности с остальными. Из анализа существующих решений в предыдущем разделе видно, что методы извлечения трасс могут зависеть от требований к масштабированию подхода и от самих используемых для анализа программ (исходный код, исполняемые файлы, наличие тестов, необходимое окружение). Метод извлечения трасс в свою очередь определяет применимые для восстановления моделей методы. Поэтому важно комплексно подходить к выбору путей решения каждой из указанных составляющих.

Выбор путей решения в рамках данной работы будет основан на гипотезе о том, что в текущем состоянии предметной области получение части спецификаций, связанных с поведенческими моделями библиотек, является очень трудозатратным и требует автоматизации. Даже при использовании инструментов, предоставленных авторами статей, пользователю необходимо самостоятельно найти подходящий проект. Затем, в случае применения динамических методов, убедиться в наличии тестов или заняться их генерацией и оценить содержательность получаемых трасс. Если говорить про статические подходы, то готовых решений обнаружено не было. Пользователь будет вынужден самостоятельно разрабатывать анализы на основе фреймворков СА или изучать доступные символьные машины с целью применения их для сбора трасс. Только после успешного решения подобных задач и связанных с ними проблем, можно перейти к самому восстановлению трасс. К счастью, забегая вперед, MINT@mint предлагает действительно удобный и рабочий модульный инструмент для применения собственного алгоритма восстановления, а также k-tail и gk-tail. Тем не менее, для получения КА на данный момент требуется преодолеть ряд сложных и не очевидных задач, требующих определенного погружения в область анализа ПО.

== Поиск проектов

В качестве источников проекта предлагается использовать GitHub и Maven Central Repository. Рассмотрим данные варианты подробнее.

GitHub является крупнейшим сервисом хранения программных репозиториев и на текущий момент содержит более 420 миллионов репозиториев@github. При этом GitHub предоставляет возможности поиска по коду и фильтрации, реализованные в рамках API.  При этом репозитории могут содержать артефакты программ, а именно JAR файлы. Их наличие позволит избежать этапа сборки, тем самым ускоряя процесс анализа проекта и потенциально повышая число успешно обработанных проектов, так как для статического анализа необходимы бинарные файлы.

Не смотря на большое количество проектов на GitHub, среди них могут быть как серьезные рабочие проекты, так и множество неработоспособных программ. Поэтому в качестве альтернативы есть возможность использовать Maven Central Repository, где среднее качество проектов должно быть значительно выше. Репозиторий Maven предлагает поиск библиотек по API. Для каждого пакета можно получить список зависимых от него, что и требуется для поиска примеров использования.

== Подготовка проектов к анализу

Для применения статических подходов необходимы скомпилированные программы. Для динамических же необходим еще и исходный код, поскольку тесты редко упаковываются в JAR файл и находятся непосредственно с самим кодом. Из этого возникает необходимость выполнять сборку проектов перед извлечением трасс. Опираясь на то, что JVM решает вопрос зависимости от платформы, а Java гарантирует обратную совместимость, можно предположить, что при существовании зависимостей, указанных в проекте, и совпадении версий сборщиков Maven или Gradle,  будет возможно успешно собрать определенную долю проектов.  

== Извлечение трасс

Для извлечения трасс будут применяться как статический, так и динамический анализ. В рамках данной работы предполагается, что с помощью динамического подхода в автоматическом режиме будет получено сильно меньше трасс, чем с помощью статического. Более того, уже имеющиеся тесты не гарантируют целостность получаемых трасс ввиду возможного мокирования и искусственного создания объектов с помощью reflection, что будет необходимо учесть при проектировании инструмента.

Предлагаемый статический подход заключается в анализе межпроцедурного графа потока управления (в дальнейшем ICFG), поиску в нем вызовов искомой библиотеки и последующему применению Points-to анализа для определения объектов вызовов и формирования трасс. По умолчанию предполагается использования анализа на основе алгоритма Андерсона -- для возможности применения такого подхода к реальным большим проектам мы вынуждены использовать не чувствительные к контексту или потоку алгоритмы.

Что касается динамического подхода, в рамках данной работы мы остановимся на сборе исключительно последовательностей вызовов, игнорируя значения аргументов и состояние программы. Сделано это с целью ограничить сложность работы, так как первоочередной целью является апробация идеи автоматизированного подхода к извлечению поведенческих моделей. Сбор информации должен осуществляться через инструментацию и запуск тестов. При отсутствии тестов в проекте или при недостаточном количестве полученных трасс предлагается воспользоваться методом фаззинга входных точек в программу с помощью Jazzer#footnote("https://github.com/CodeIntelligenceTesting/jazzer"). Фаззинг позволит обеспечить целостность получаемых трасс в случае успешного запуска.

== Восстановление поведенческой модели

Так как в рамках данной работы мы оперируем трассами, состоящими исключительно из последовательностей вызовов, то это сильно ограничивает выбор алгоритма восстановления. Предлагается использовать алгоритм k-tail, реализованный в рамках инструмента MINT. В первую очередь, это сэкономит время на реализацию алгоритма. Также благодаря прозрачному принципу восстановления интерпретация получаемых КА будет проще. Помимо этого, MINT содержит реализации алгоритмов, использующих информацию о переменных, что будет полезно при развитии инструмента.

== Общий подход

Из предложенных способов решения задач складывается общий подход. Мы должны получать проекты с GitHub и репозитория Maven, использующие заданную библиотеку. Далее необходимо подготовить проекты к извлечению трасс, выполнив компиляцию исходного кода и тестов. При отсутствии тестов или малом количестве полученных трасс следует предпринять попытку фаззинга точек входа в программу. Затем необходимо извлечь трассы с применением описанных выше подходов и подать полученные результаты на вход алгоритму восстановления поведенческой модели в виде КА. Каждый из шагов имеет множество сопутствующих проблем и будет подробно рассмотрен в следующем разделе, посвященном проектированию инструмента.