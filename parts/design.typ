= Проектирование

Перед реализацией предложенного подхода по получению поведенческих моделей библиотек необходимо сформулировать схему работы основных его составляющих и их взаимодействия. В данном разделе рассмотрены общая схема работы инструмента, получение и подготовка проектов, извлечение трасс и восстановление из них поведенческих моделей.

== Общая схема работы

На @genscheme в общих чертах представлен полный цикл работы разрабатываемого инструмента. Предполагается возможность выбора режима работы, что позволит пропускать определенные этапы. Например, восстанавливать КА из заранее накопленных данных или извлекать трассы из уже подготовленных проектов, что не отражено на схеме. Цифрами обозначены основные части инструмента, которые будут рассмотрены в данной главе:
+ Получение и подготовка проектов
+ Извлечение трасс
+ Восстановление поведенческих моделей

Общая последовательность действий заключается в том, что изначально пользователь конфигурирует инструмент -- задаёт целевую библиотеку, определяет параметры используемых алгоритмов, указывает пути к требуемому окружению и выбирает режим работы. Далее итеративно выполняется поиск проектов, их подготовка и извлечение трасс с последующим сохранением. После анализа заданного количества проектов или каких-либо других установленных условий остановки выполняется обработка полученных трасс и восстановление КА. На более детальном уровне каждый шаг разобран в соответствующих подразделах.

#figure(
  image("../img/genscheme.png"),
  caption: "Общая схема работы"
) <genscheme>

== Получение и подготовка проектов

В качестве источника проектов предлагается использовать GitHub и Maven Central Repository. Каждый из них имеет свои механизмы поиска и получения проектов, поэтому рассмотрим их раздельно. Дополнительно должна быть предусмотрена возможность использования заранее подготовленных проектов. Также для анализа необходимы JAR файлы проектов и их зависимости, поэтому следует реализовать их автоматическую сборку.

=== GitHub

Для GitHub мы вынуждены использовать поиск по коду, так как другие варианты найти проекты, использующие заданную библиотеку, отсутствуют. Пользователь может указать в качестве поискового запроса импорт основного пакета библиотеки или момент её подключения в build.gradle или pom.xml файле. При этом репозитории, помимо исходного кода, могут содержать другую полезную информацию:
- Тесты. Они необходимы для получения трасс с помощью динамического анализа
- JAR файлы. Наличие бинарного файла увеличивает вероятность того, что проект рабочий, а также избавляет от необходимости выполнять его компиляцию для статического извлечения трасс. В случае применения динамических подходов необходимо компилировать программу для получения её зависимостей
- Конкретные версии программы. При выпуске версии фиксируется коммит, определяющий состояние исходного кода на тот момент. Это также повышает вероятность того, что проект рабочий

При реализации модуля получения проектов должна быть предусмотрена возможность сбора всей полезной информации и фильтрация по ней, чтобы обеспечить возможность работы только с репозиториями, содержащими тесты или скомпилированные программы. Также необходимо отслеживать обработанные репозитории, так как в результатах поиска один проект может содержаться несколько раз.

Для поиска и получения проектов GitHub предоставляет бесплатный application programming interface (API). В случае отсутствия артефактов, получение проектов может быть реализовано через git.

=== Maven Central

Maven Central Repository содержит информацию об общедоступных библиотеках, а также об их зависимостях и зависящих от них проектов. Таким образом, есть возможность узнать, где используется заданная библиотека. Найденные подобным образом проекты являются целью анализа. Для работы с Maven Repository пользователь должен указать библиотеку и её версию.

Получение проектов предлагается выполнять с помощью Gradle, так как это позволит автоматически собрать её и получить зависимости. Получение исходного кода, хранящегося в Maven Central, бессмысленно, так как он не содержит тестов. На странице библиотек в Maven Central иногда расположены ссылки на GitHub репозитории, однако их нельзя получить с помощью API, а автоматическое получение и парсинг страниц может привести к блокировке на ресурсе.

Для получения информации о зависящих библиотек от заданной также не предусмотрен общий API. Однако после определенного исследования было обнаружено, что существует некий внутренний API, который реализует данную возможность. Чтобы убедиться в возможности использования данного API, был сделан запрос на почту по контактам Maven, где сообщили, что проблемы могут возникнуть только в случае попытки массовой выгрузки всего Maven Central, а это не входит в план работы.

=== Сборка

В рамках работы будут рассматриваться только проекты, использующие Gradle и Maven в качестве систем сборки, так как они используются чаще всего и относительно легко поддаются автоматизации.

Для работы с Gradle существует Gradle Tooling API, позволяющий автоматически получать необходимую версию сборщика и программно вызывать необходимые задачи. При этом остается возможность использовать конкретную версию для всех проектов или предустановленный Gradle. Maven не имеет подобного API, в связи с чем необходима предустановленная система сборки.

Java гарантирует обратную совместимость со старыми версиями, а JVM решает большинство проблем зависимости от платформы. Благодаря этому можно рассчитывать на успешную сборку определенной доли программ. Тем не менее, есть несколько причин, по которым не все проекты могут быть собраны:
- Проект может использовать специфические зависимости, получение и сборка которых выполняется вручную или иными способами
- Проект может использовать зависимости, которые больше недоступны из заданных репозиториев библиотек

Решение подобных проблем позволит увеличить процент собираемых программ, но это отдельная большая задача. В рамках данной работы она не будет рассматриваться. Мы вынуждены принять тот факт, что не все программы будут собраны.

== Извлечение трасс

Для извлечения трасс предлагается использовать статический и динамический подходы. Каждый из них имеет сложную схему работы, определенные детали и требует тщательной разработки соответствующих методов.

=== Статический подход

Примерный алгоритм извлечения трасс с применением статического анализа представлен на @static_scheme. Общий подход заключается в том, что строится межпроцедурный граф потока управления для программы. Также необходимо получить набор точек входа в программу. Из каждой такой точки выполняется обход ICFG, в рамках которого выполняется обнаружение и сбор вызовов заданной библиотеки. Для каждого вызова определяется объект, над которым он выполняется, и с помощью анализа указателей формируются трассы для каждого объекта. Полученные трассы сохраняются для последующего восстановления поведенческой модели.

Что касается получения точек входа, предлагается предоставить пользователю возможность создавать определенные фильтры для методов, включающие в себя следующие параметры:
- Аннотации метода и класса
- Регулярное выражение для названия метода и класса
- Вид метода (конструктор, метод, блок статической инициализации)
- Типы аргументов и тип возвращаемого значения метода
- Модификаторы для метода и класса

Подобный набор должен обеспечить возможность поиска специфических точек входа. Как пример, это могут быть методы, отвечающие за обработку запросов по URL в различных фреймворках для создания веб-приложений. 

#figure(
  image("../img/static_scheme.png", height: 90%),
  caption: "Схема извлечения трасс с помощью статического анализа"
) <static_scheme>

Необходимость выполнения анализа указателей обусловлена тем, что общая последовательность нерепрезентативна и не содержит в себе реальных переходов и состояний библиотеки. Рассмотрим простой пример на @calls_example.

#figure(
  ```java
  FileOutputStream dest = new FileOutputStream(file);
  ZipOutputStream zip1 = new ZipOutputStream(new BufferedOutputStream(dest));
  ZipOutputStream zip2 = new ZipOutputStream(new BufferedOutputStream(dest));
  zip1.write(1);
  zip1.close();
  zip2.write(1);
  zip2.close();```,
  caption: "Пример последовательностей вызовов"
) <calls_example>

Извлекаемая трасса при игнорировании объектов будет выглядеть примерно как на @trace_wrong_example.

#figure(
  ```txt
  1. init
  2. init
  3. write
  4. close
  5. write
  6. close```,
  caption: "Пример некорректной трассы"
) <trace_wrong_example>

При восстановлении поведенческой модели окажется, что мы допускаем запись после того, как закрыли ZipOutputStream. Очевидно, такая модель не соответствует действительности. Применив points-to анализ мы рассчитываем получить две идентичные трассы как на @trace_right_example.

#figure(
  ```txt
  1. init
  2. write
  3. close```,
  caption: "Пример правильной трассы"
) <trace_right_example>

Предполагается применять points-to анализ на основе алгоритма Андерсена, так как это один самых точных (нечувствительных к контексту и потоку) алгоритмов, которые могут быть применимы для всей программы межпроцедурно. Конечно, существуют гораздо более точные алгоритмы, однако ввиду экспоненциальной сложности их использование в таких условиях невозможно. В качестве инструмента для статического анализа выбран Soot#footnote("https://github.com/soot-oss/soot"), так как он предоставляет возможности для построения ICFG, конкретные реализации points-to анализа, а также предлагает средства для инструментации программ, что будет необходимо для динамического подхода по извлечению трасс.

=== Динамических подход

Извлечение трасс с помощью динамического анализа заключается в предварительной инструментации на уровне байт-кода и последующем запуске программы. Инструментация может быть выполнена с помощью Soot и заключается во вставке специального кода после каждого вызова библиотеки. Вставленный код позволяет получить информацию о вызове и его объекте. Чтобы точно различать экземпляры объектов между собой, может быть использован identity hash code.

Чтобы получить трассы после инструментации, программу необходимо запустить. Для этого предлагается использовать тесты при их наличии и фаззинг входных точек в программу. Входные точки предлагается получать тем же способом, что и при статическом анализе.

В качестве инструмента для фаззинга предлагается использовать Jazzer#footnote("https://github.com/CodeIntelligenceTesting/jazzer"). Он поставляется в виде JAR файла и имеет режим автоматического фаззинга для указанных точек входа без предварительной подготовки целевого проекта. Для генерации данных Jazzer создаёт случайные массивы байт, интерпретируемые как необходимый объект и впоследствии мутирует их для увеличения покрытия кода.

Общая схема динамического извлечения трасс представлена на @dynamic_scheme.

#figure(
  image("../img/dynamic_scheme.png", height: 40%),
  caption: "Схема извлечения трасс с помощью динамического анализа"
) <dynamic_scheme>

== Восстановление поведенческих моделей

Из накопленных трасс необходимо восстановить поведенческую модель в виде КА. Для этого следует обработать полученные трассы и сформировать входные данные для алгоритма k-tail. Что касается обработки, ввиду использования двух подходов для извлечения трасс, возможно реализовать несколько режимов работы:
- Полученные разными способами трассы объединяются в единое множество и строится общий КА
- Для каждого способа получения трасс строятся соответствующие КА
- Динамические трассы являются верификатором для статических: в случае совпадения динамической трассы с подпоследовательностью статической, последняя считается подтверждённой

Имеет смысл попытаться уменьшить количество некорректных трасс. Трассы могут повторяться между собой, и если считать количество таких повторений для каждой трассы, мы получим частотное распределение. Чтобы исключить погрешности, можно воспользоваться фильтрацией по частоте повторения трасс, устанавливая абсолютный или относительный порог.

Получаемый в результате работы алгоритма КА может содержать ложные конечные состояния из-за слияний. Для правильного определения состояния необходимо их обойти и обозначить как конечные лишь те, из которых отсутствуют какие-либо переходы. После этого конечные состояния следует объединить, что приведет к сокращению состояний КА без потери информации о переходах.  

Вместо собственной реализации алгоритма k-tail предлагается использовать фреймворк MINT, рассмотренный в рамках обзора существующих работ в области восстановления поведенческих моделей. Помимо этого, MINT содержит реализации алгоритмов, использующих информацию о переменных, что будет полезно при развитии инструмента.

Получаемые с помощью MINT КА выводятся в формате dot. Для более универсального представления, предлагается транслировать их в JSON.

== Результат проектирования

В результате рассмотрены основные задачи и способы их решения, включая используемые инструменты и важные детали реализации. Для общего понимания представлены схемы предлагаемого подхода и наиболее сложных его частей. 