= Проектирование

Перед реализацией предложенного подхода по получению поведенческих моделей библиотек необходимо сформулировать схему работы основных его составляющих и их взаимодействия друг с другом. В данном разделе рассмотрены общая схема работы инструмента, получение и подготовка проектов, извлечение трасс и восстановление из них поведенческих моделей.

== Общая схема работы

На @genscheme в общих чертах представлен полный цикл работы разрабатываемого инструмента. Предполагается, что у пользователя будет возможность выбора режима работы, что позволит пропускать определенные этапы и, например, восстанавливать КА из заранее накопленных данных или извлекать трассы из уже подготовленных проектов, что не отражено на схеме. Цифрами обозначены основные части инструмента, которые будут рассмотрены в данной главе:
+ Получение и подготовка проектов
+ Извлечение трасс
+ Восстановление поведенческих моделей

Общая последовательность действий заключается в том, что изначально пользователь конфигурирует инструмент -- задает целевую библиотеку, определяет параметры используемых алгоритмов, указывает пути к требуемому окружению и выбирает режим работы. Далее итеративно выполняется поиск проектов, их подготовка и извлечение трасс с последующим сохранением. После анализа заданного количества проектов или каких-либо других установленных условий остановки выполняется обработка полученных трасс и восстановление КА. На более детальном уровне каждый шаг разобран в соответствующих подразделах.

#figure(
  image("../img/genscheme.png"),
  caption: "Общая схема работы"
) <genscheme>

== Получение и подготовка проектов

В качестве источника проектов предлагается использовать GitHub и Maven Central Repository. Каждый из них имеет свои механизмы поиска и получения проектов, поэтому рассмотрим их раздельно. Дополнительно должна быть предусмотрена возможность использования заранее подготовленных проектов. Также для анализа необходимы JAR файлы проектов и их зависимости, поэтому необходимо реализовать их автоматическую сборку.

=== GitHub

Для GitHub мы вынуждены использовать поиск по коду, так как других вариантов найти проекты, использующие заданную библиотеку, отсутствуют. Пользователь может указать в качестве исходного кода импорт основного пакета библиотеки или момент ее подключения в build.gradle или pom файле. При этом репозитории помимо исходного кода могут содержать другую полезную информацию:
- Тесты. Они необходимы для получения трасс с помощью динамического анализа.
- JAR файлы. Наличие бинарного файла увеличивает вероятность того, что проект рабочий, а также избавляет от необходимости выполнять его компиляцию для статического извлечения трасс. В случае применения динамических подходов необходимо компилировать программу для получения ее зависимостей.
- Конкретные версии программы. При выпуске версии фиксируется соответствующий коммит, фиксирующий исходный код. Это также повышает вероятность того, что проект рабочий.

При реализации получения проектов должна быть предусмотрена возможность сбора всей полезной информации и фильтрация по ней, чтобы обеспечить возможность работы только с репозиториями, содержащими тесты или скомпилированные программы. Также необходимо отслеживать обработанные репозитории, так как в результатах поиска один проект может содержаться несколько раз.

Для поиска и получения проектов GitHub предоставляет бесплатное API. В случае отсутствия артефактов, получение проектов может быть реализовано через git.

=== Maven Central

Maven Central Repository содержит информацию об общедоступных библиотеках, а также об их зависимостях и зависящих от них проектов. Таким образом, есть возможность узнать где используется заданная библиотека -- это нас и интересует. Для работы с Maven Repository пользователь должен указать библиотеку и ее версию в определенном формате.

Получение проектов предлагается выполнять с помощью gradle, так как это позволит автоматически собрать ее и разрешить зависимости. Получение исходного кода, хранящегося в Maven Central не имеет смысла, так как он не содержит тестов. На странице библиотек в Maven Central иногда расположены ссылки на GitHub репозитории, однако их нельзя получить с помощью API, а автоматическое получение и парсинг страниц может привести к блокировке на ресурсе.

Для получения информации о зависящих библиотек от заданной также не предусмотрен общий API. Однако после определенного исследования было обнаружено, что существует некий внутренний API, который реализует данную возможность. Чтобы убедиться в возможности использования данного API был сделан запрос на почту по контактам Maven, где сообщили, что проблемы могут возникнуть только в случае попытки массовой выгрузки всего Maven Central, что не предполагается в рамках проекта.

=== Сборка

В рамках работы будут рассматриваться только проекты, использующие Gradle и Maven в качестве системы сборки, так как они используются чаще всего и относительно легко поддаются автоматизации.

Для работы с Gradle существует Gradle Tooling API, позволяющий автоматически получать необходимую версию сборщика и программно вызывать необходимые задачи. При этом остается возможность использовать конкретную версию для всех проектов или использовать предустановленный Gradle. Maven не имеет подобного API, в связи с чем необходима предустановленная система сборки.

Java гарантирует обратную совместимость со старыми версиями, а JVM решает большинство проблем зависимости от платформы. Благодаря этому можно рассчитывать на успешную сборку определенной доли программ. Тем не менее, есть несколько причин, по которой не все проекты могут быть собраны:
- Проект может использовать специфические зависимости, получение и сборка которых не может быть автоматизирована
- Проект может использовать зависимости, которые уже не доступных из заданных репозиториев библиотек

С этими факторами ничего нельзя поделать и мы вынуждены принять тот факт, что не все программы будут собраны.

== Извлечение трасс

Для извлечение трасс предлагается использовать статический и динамический подходы. Каждый из них имеет сложную схему работы и определенные детали, что требует тщательной разработки методов извлечения.

=== Статический подход

Примерный алгоритм извлечения трасс с применением статического анализа представлен на @extract_scheme. Общий подход заключается в том, что строится межпроцедурный граф потока управления для программы. Также необходимо получить набор точек входа в программу. Из каждой такой точки выполняется обход ICFG, в рамках которого выполняется обнаружение и сбор вызовов заданной библиотеки. Для каждого вызова определяется объект, над которым он выполняется, и с помощью points-to анализа формируются трассы для каждого объекта. Полученные трассы сохраняются для последующего восстановления поведенческой модели.

Что касается получения точек входа, предлагается предоставить пользователю возможность создавать определенные фильтры для методов, содержащие следующие параметры:
- Теги метода
- Теги класса
- Регулярное выражение для названия метода
- Регулярное выражение для названия класса
- Модификатор доступа метода (для исследования всех публичных методов)
- Типы аргументов метода

Подобный набор должен обеспечить возможность поиска специфических точек входа. Как пример, это могут быть методы, отвечающие за обработку запросов по URL путям в различных фреймворках для создания веб-приложений. 

#figure(
  image("../img/extract.png"),
  caption: "Схема извлечения трасс с помощью статического анализа"
) <extract_scheme>

Необходимость выполнения points-to анализа обусловлена тем, что общая последовательность нерепрезентативна и не содержит в себе реальных переходов и состояний библиотеки. Рассмотрим простой пример на @calls_example.

#figure(
  ```java
  FileOutputStream dest = new FileOutputStream(file);
  ZipOutputStream zip1 = new ZipOutputStream(new BufferedOutputStream(dest));
  ZipOutputStream zip2 = new ZipOutputStream(new BufferedOutputStream(dest));
  zip1.write(1);
  zip1.close();
  zip2.write(1);
  zip2.close();```,
  caption: "Пример последовательностей вызовов"
) <calls_example>

Извлекаемая трасса при игнорировании объектов будет выглядеть примерно как на @trace_wrong_example.

#figure(
  ```txt
  1. init
  2. init
  3. write
  4. close
  5. write
  6. close```,
  caption: "Пример некорректной трассы"
) <trace_wrong_example>

При восстановлении поведенческой модели окажется, что мы допускаем запись после того, как закрыли ZipOutputStream. Очевидно, такая модель не соответствует действительности. Применив points-to анализ мы рассчитываем получить две идентичные трассы как на @trace_right_example.

#figure(
  ```txt
  1. init
  2. write
  3. close```,
  caption: "Пример правильной трассы"
) <trace_right_example>

Предполагается применять points-to анализ на основе алгоритма Андерсена, так как это один самых точных алгоритмов, которые могут быть применимы в для всей программы межпроцедурно. Конечно, существуют гораздо более точные алгоритмы, однако ввиду экспоненциальной сложности их использование в таких условиях невозможно.

=== Динамических подход

Извлечение трасс с помощью динамического анализа заключается в предварительной инструментации на уровне байт-кода и последующем запуске программы. Инструментация заключается во вставке специального кода после каждого вызова библиотеки, который позволяет получить информацию о вызове и объекте. Для того, чтобы точно различать экземпляры объектов между собой, может быть использован identity hash code.

Чтобы получить трассы после инструментации, программу необходимо запустить. Для этого предлагается использовать тесты при их наличии и фаззинг входных точек в программу. Входные точки предлагается получать тем же образом, что и при статическом анализе.

Общая схема динамического извлечения трасс представлена на .

== Восстановление поведенческих моделей


== Результат проектирования